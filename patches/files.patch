diff --recursive -w -u orig-modules/aitc/modules/client.js modules/aitc/modules/client.js
--- orig-modules/aitc/modules/client.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/aitc/modules/client.js	2012-05-02 17:57:27.000000000 -0500
@@ -120,7 +120,8 @@
 
         // Convert apps from remote to local format
         var apps = [];
-        for each (var app in tmp) {
+        for (var i = 0; i < tmp.length; i++) {
+          var app = tmp[i];
           apps.push(self._makeLocalApp(app));
         }
 
@@ -128,7 +129,7 @@
         cb(null, apps);
 
         // Don't update lastModified until we know cb succeeded.
-        self._appsLastModified = parseInt(req.response.headers['x-timestamp']);
+        self._appsLastModified = parseInt(req.response.headers['x-timestamp'], 10);
       } catch (e) {
         self._log.error("Exception in getApps " + e);
       }
@@ -141,7 +142,8 @@
    * don't store them on the server.
    */
   _makeRemoteApp: function _makeRemoteApp(app) {
-    for each (var key in this.requiredLocalKeys) {
+    for (var i = 0; i < this.requiredLocalKeys.length; i++) {
+      var key = this.requiredLocalKeys[i];
       if (!app[key]) {
         throw new Error("Local app missing key " + key);
       }
@@ -167,7 +169,8 @@
    * registry expects. (Inverse of _makeRemoteApp)
    */
   _makeLocalApp: function _makeLocalApp(app) {
-    for each (var key in this._requiredRemoteKeys) {
+    for (var i = 0; i < this._requiredRemoteKeys; i++) {
+      var key = this._requiredRemoteKeys[i];
       if (!app[key]) {
         throw new Error("Remote app missing key " + key);
       }
@@ -271,8 +274,8 @@
     }
 
     var time = new Date().getTime();
-    var lastReq = parseInt(PREFS.get("lastReq", 0));
-    var backoff = parseInt(PREFS.get("backoff", 0));
+    var lastReq = parseInt(PREFS.get("lastReq", 0), 10);
+    var backoff = parseInt(PREFS.get("backoff", 0), 10);
 
     if (lastReq + (backoff * 1000) < time) {
       this._log.warn("X-Backoff is " + backoff + ", not making request");
@@ -300,5 +303,5 @@
       this._backoff = true;
       PREFS.set("backoff", backoff + "");
     }
-  },
+  }
 };
\ No newline at end of file
diff --recursive -w -u orig-modules/aitc/modules/manager.js modules/aitc/modules/manager.js
--- orig-modules/aitc/modules/manager.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/aitc/modules/manager.js	2012-05-02 17:54:47.000000000 -0500
@@ -164,7 +164,7 @@
       {
         notify: function _getTimerNotify() {
           self._checkServer();
-        },
+        }
       }, getFreq, Ci.nsITimer.TYPE_REPEATING_SLACK
     );
     this._log.info("GET timer set, next attempt in " + getFreq + "ms");
@@ -429,6 +429,6 @@
     BrowserID.getAssertion(gotSilentAssertion, {
       audience: this.DASHBOARD, sameEmailAs: this.MARKETPLACE
     });
-  },
+  }
 
 };
diff --recursive -w -u orig-modules/aitc/modules/storage.js modules/aitc/modules/storage.js
--- orig-modules/aitc/modules/storage.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/aitc/modules/storage.js	2012-05-02 17:54:27.000000000 -0500
@@ -193,7 +193,7 @@
       this._writeLock = false;
       cb(msg);
     }
-  },
+  }
 };
 
 /**
@@ -244,7 +244,8 @@
     var localApps = {};
     
     // Convert lApps to a dictionary of origin -> app (instead of id -> app).
-    for (var [id, app] in Iterator(localApps)) {
+    for (var id in localApps) {
+      var app = localApps[id];
       app.id = id;
       toDelete[app.origin] = app;
       localApps[app.origin] = app;
@@ -252,7 +253,8 @@
 
     // Iterate over remote apps, and find out what changes we must apply.
     var toInstall = [];
-    for each (var app in remoteApps) {
+    for (var i = 0; i < remoteApps.length; i++) {
+      var app = remoteApps[i];
       // Don't delete apps that are both local & remote.
       var origin = app.origin;
       delete toDelete[origin];
@@ -381,7 +383,7 @@
 
       callback(err, manifest);
     });
-  },
+  }
 
 };
 
diff --recursive -w -u orig-modules/common/log4moz.js modules/common/log4moz.js
--- orig-modules/common/log4moz.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/common/log4moz.js	2012-05-02 17:53:11.000000000 -0500
@@ -185,7 +185,7 @@
 
   _level: null,
   get level() {
-    if (this._level != null)
+    if (this._level !== null)
       return this._level;
     if (this.parent)
       return this.parent.level;
@@ -197,7 +197,7 @@
   },
 
   _parent: null,
-  get parent() this._parent,
+  get parent() {return this._parent;},
   set parent(parent) {
     if (this._parent == parent) {
       return;
@@ -335,7 +335,7 @@
 
     // trigger updates for any possible descendants of this logger
     for (var logger in this._loggers) {
-      if (logger != name && logger.indexOf(name) == 0)
+      if (logger != name && logger.indexOf(name) === 0)
         this._updateParents(logger);
     }
   },
diff --recursive -w -u orig-modules/common/observers.js modules/common/observers.js
--- orig-modules/common/observers.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/common/observers.js	2012-05-02 17:52:33.000000000 -0500
@@ -91,9 +91,9 @@
     // we can make it.  We could index by topic, but we can't index by callback
     // or thisObject, as far as I know, since the keys to JavaScript hashes
     // (a.k.a. objects) can apparently only be primitive values.
-    var [observer] = this._cache.filter(function(v) v.topic      == topic    &&
+    var observer = this._cache.filter(function(v) {return v.topic      == topic    &&
                                                     v.callback   == callback &&
-                                                    v.thisObject == thisObject);
+                                                    v.thisObject == thisObject;})[0];
     if (observer) {
       this._service.removeObserver(observer, topic);
       this._cache.splice(this._cache.indexOf(observer), 1);
diff --recursive -w -u orig-modules/common/preferences.js modules/common/preferences.js
--- orig-modules/common/preferences.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/common/preferences.js	2012-05-02 17:52:00.000000000 -0500
@@ -78,7 +78,7 @@
    */
   get: function(prefName, defaultValue) {
     if (Array.isArray(prefName))
-      return prefName.map(function(v) this.get(v, defaultValue), this);
+      return prefName.map(function(v) {return this.get(v, defaultValue);}, this);
 
     if (this._site)
       return this._siteGet(prefName, defaultValue);
@@ -137,8 +137,8 @@
    */
   set: function(prefName, prefValue) {
     if (isObject(prefName)) {
-      for (var [name, value] in Iterator(prefName))
-        this.set(name, value);
+      for (var name in prefName)
+        this.set(name, prefName[name]);
       return;
     }
 
@@ -150,7 +150,7 @@
 
   _set: function(prefName, prefValue) {
     var prefType;
-    if (typeof prefValue != "undefined" && prefValue != null)
+    if (typeof prefValue != "undefined" && prefValue !== null)
       prefType = prefValue.constructor.name;
 
     switch (prefType) {
@@ -174,7 +174,7 @@
                 "32-bit integer range -(2^31-1) to 2^31-1.  To store numbers " +
                 "outside that range, store them as strings.");
         this._prefSvc.setIntPref(prefName, prefValue);
-        if (prefValue % 1 != 0)
+        if (prefValue % 1 !== 0)
           Cu.reportError("Warning: setting the " + prefName + " pref to the " +
                          "non-integer number " + prefValue + " converted it " +
                          "to the integer number " + this.get(prefName) +
@@ -258,7 +258,7 @@
 
   reset: function(prefName) {
     if (Array.isArray(prefName)) {
-      prefName.map(function(v) this.reset(v), this);
+      prefName.map(function(v) {return this.reset(v);}, this);
       return;
     }
 
@@ -390,9 +390,9 @@
     // make it.  We could index by fullBranch, but we can't index by callback
     // or thisObject, as far as I know, since the keys to JavaScript hashes
     // (a.k.a. objects) can apparently only be primitive values.
-    var [observer] = observers.filter(function(v) v.prefName   == fullPrefName &&
+    var observer = observers.filter(function(v) {return v.prefName   == fullPrefName &&
                                                   v.callback   == callback &&
-                                                  v.thisObject == thisObject);
+                                                  v.thisObject == thisObject;})[0];
 
     if (observer) {
       Preferences._prefSvc.removeObserver(fullPrefName, observer);
@@ -439,7 +439,7 @@
       prefSvc = prefSvc.getBranch(this._prefBranch);
     }
 
-    this.__defineGetter__("_prefSvc", function() prefSvc);
+    this.__defineGetter__("_prefSvc", function() {return prefSvc;});
     return this._prefSvc;
   },
 
@@ -450,7 +450,7 @@
   get _ioSvc() {
     var ioSvc = Cc["@mozilla.org/network/io-service;1"].
                 getService(Ci.nsIIOService);
-    this.__defineGetter__("_ioSvc", function() ioSvc);
+    this.__defineGetter__("_ioSvc", function() {return ioSvc;});
     return this._ioSvc;
   },
 
@@ -461,7 +461,7 @@
   get _contentPrefSvc() {
     var contentPrefSvc = Cc["@mozilla.org/content-pref/service;1"].
                          getService(Ci.nsIContentPrefService);
-    this.__defineGetter__("_contentPrefSvc", function() contentPrefSvc);
+    this.__defineGetter__("_contentPrefSvc", function() {return contentPrefSvc;});
     return this._contentPrefSvc;
   }
 
@@ -498,7 +498,7 @@
     // The pref service only observes whole branches, but we only observe
     // individual preferences, so we check here that the pref that changed
     // is the exact one we're observing (and not some sub-pref on the branch).
-    if (data.indexOf(this.prefName) != 0)
+    if (data.indexOf(this.prefName) !== 0)
       return;
 
     if (typeof this.callback == "function") {
@@ -518,6 +518,6 @@
   // We can't check for |val.constructor == Object| here, since the value
   // might be from a different context whose Object constructor is not the same
   // as ours, so instead we match based on the name of the constructor.
-  return (typeof val != "undefined" && val != null && typeof val == "object" &&
+  return (typeof val != "undefined" && val !== null && typeof val == "object" &&
           val.constructor.name == "Object");
 }
diff --recursive -w -u orig-modules/common/rest.js modules/common/rest.js
--- orig-modules/common/rest.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/common/rest.js	2012-05-02 17:47:56.000000000 -0500
@@ -231,7 +231,7 @@
    *
    * @return the request object.
    */
-  delete: function delete_(onComplete, onProgress) {
+  "delete": function delete_(onComplete, onProgress) {
     return this.dispatch("DELETE", null, onComplete, onProgress);
   },
 
@@ -615,5 +615,5 @@
     return RESTRequest.prototype.dispatch.call(
       this, method, data, onComplete, onProgress
     );
-  },
+  }
 };
diff --recursive -w -u orig-modules/common/utils.js modules/common/utils.js
--- orig-modules/common/utils.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/common/utils.js	2012-05-02 17:45:42.000000000 -0500
@@ -149,7 +149,11 @@
   },
 
   byteArrayToString: function byteArrayToString(bytes) {
-    return [String.fromCharCode(byte) for each (byte in bytes)].join("");
+    var result = [];
+    for (var i = 0; i < bytes.length; i++) {
+      result.push(String.fromCharCode(bytes[i]));
+    }
+    return result.join("");
   },
 
   bytesAsHex: function bytesAsHex(bytes) {
@@ -179,7 +183,10 @@
     // is turned into 8 characters from the 32 character base.
     var ret = "";
     for (var i = 0; i < bytes.length; i += 5) {
-      var c = [byte.charCodeAt() for each (byte in bytes.slice(i, i + 5))];
+      var c = [];
+      for (var j = i; j < i + 5; j++) {
+        c.push(bytes.charCodeAt(i));
+      }
       ret += key[c[0] >> 3]
            + key[((c[0] << 2) & 0x1f) | (c[1] >> 6)]
            + key[(c[1] >> 1) & 0x1f]
@@ -229,7 +236,7 @@
 
       function advance() {
         c  = str[cOffset++];
-        if (!c || c == "" || c == "=") // Easier than range checking.
+        if (!c || c === "" || c == "=") // Easier than range checking.
           throw "Done";                // Will be caught far away.
         val = key.indexOf(c);
         if (val == -1)
@@ -237,8 +244,9 @@
       }
 
       // Handle a left shift, restricted to bytes.
-      function left(octet, shift)
-        (octet << shift) & 0xff;
+      function left(octet, shift) {
+        return (octet << shift) & 0xff;
+      }
 
       advance();
       accumulate(left(val, 3));
@@ -299,7 +307,7 @@
     var len = b64.length;
     var over = len % 4;
     return over ? atob(b64.substr(0, len - over)) : atob(b64);
-  },
+  }
 };
 
 XPCOMUtils.defineLazyGetter(CommonUtils, "_utf8Converter", function() {
diff --recursive -w -u orig-modules/crypto/modules/utils.js modules/crypto/modules/utils.js
--- orig-modules/crypto/modules/utils.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/crypto/modules/utils.js	2012-05-02 17:43:07.000000000 -0500
@@ -42,7 +42,10 @@
    */
   digestBytes: function digestBytes(message, hasher) {
     // No UTF-8 encoding for you, sunshine.
-    var bytes = [b.charCodeAt() for each (b in message)];
+    var bytes = [];
+    for (var i = 0; i < message.length; i++) {
+      bytes.push(message.charCodeAt(i));
+    }
     hasher.update(bytes, bytes.length);
     var result = hasher.finish(false);
     if (hasher instanceof Ci.nsICryptoHMAC) {
@@ -326,7 +329,7 @@
     }
 
     return header += ', ext="' + ext +'"';
-  },
+  }
 };
 
 XPCOMUtils.defineLazyGetter(CryptoUtils, "_utf8Converter", function() {
Only in modules/crypto/modules: utils.js.orig
Only in modules/crypto/modules: utils.js.rej
diff --recursive -w -u orig-modules/identity/browserid.js modules/identity/browserid.js
--- orig-modules/identity/browserid.js	2012-05-02 17:57:37.000000000 -0500
+++ modules/identity/browserid.js	2012-05-02 17:42:23.000000000 -0500
@@ -305,7 +305,7 @@
         "'email'"             +
       "));";
     Cu.evalInSandbox(scriptText, obj.sandbox, "1.8", ID_URI, 1);
-  },
+  }
 };
 
 /**
@@ -390,7 +390,7 @@
       null, // postData
       null  // headers
     );
-  },
+  }
 };
 
 XPCOMUtils.defineLazyGetter(this, "BrowserID", function() {
